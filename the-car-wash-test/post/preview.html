<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Car Wash Test: Why the Model That Solved a Quantum Breakthrough Can't Wash Your Car</title>
<style>
  :root {
    --bg: #ffffff;
    --text: #333333;
    --text-muted: #666666;
    --link: #2563eb;
    --link-hover: #1d4ed8;
    --code-bg: #f3f4f6;
    --border-muted: rgba(102, 102, 102, 0.2);
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #1a1a1a;
      --text: #e0e0e0;
      --text-muted: #a0a0a0;
      --link: #60a5fa;
      --link-hover: #93c5fd;
      --code-bg: #2d2d2d;
      --border-muted: rgba(160, 160, 160, 0.2);
    }
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    font-size: 1.125rem;
  }

  .container {
    max-width: 42rem;
    margin: 0 auto;
    padding: 2rem 1.5rem 4rem;
  }

  header {
    margin-bottom: 2rem;
  }

  header h1 {
    font-size: 1.875rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
    line-height: 1.3;
  }

  header time {
    color: var(--text-muted);
    font-size: 0.875rem;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  }

  .prose p {
    margin-bottom: 1.25rem;
  }

  .prose h2 {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 2.5rem 0 1rem;
    line-height: 1.3;
  }

  .prose h3 {
    font-size: 1.25rem;
    font-weight: 600;
    margin: 2rem 0 0.75rem;
    line-height: 1.3;
  }

  .prose a {
    color: var(--link);
    text-decoration: underline;
  }

  .prose a:hover {
    color: var(--link-hover);
  }

  .prose img {
    max-width: 100%;
    width: 100%;
    height: auto;
    border-radius: 0.5rem;
    margin: 1rem 0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  @media (prefers-color-scheme: dark) {
    .prose img {
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }
  }

  .prose strong {
    font-weight: 600;
  }

  .prose em {
    font-style: italic;
  }

  .prose ul, .prose ol {
    margin-left: 1.5rem;
    margin-bottom: 1.25rem;
  }

  .prose li {
    margin-bottom: 0.35rem;
  }

  .prose blockquote {
    border-left: 3px solid var(--border-muted);
    padding-left: 1.25rem;
    margin: 1.25rem 0;
    color: var(--text-muted);
    font-style: italic;
  }

  .prose table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    font-size: 0.95rem;
    line-height: 1.5;
  }

  .prose thead th {
    background: #f3f4f6;
    font-weight: 600;
    text-align: left;
    padding: 0.6rem 0.75rem;
    border-bottom: 2px solid #d1d5db;
  }

  .prose tbody td {
    padding: 0.55rem 0.75rem;
    border-bottom: 1px solid #e5e7eb;
  }

  .prose tbody tr:nth-child(even) {
    background: #f9fafb;
  }

  .prose tbody tr:hover {
    background: #f3f4f6;
  }

  .prose .result-pass {
    color: #15803d;
    font-weight: 600;
  }

  .prose .result-fail {
    color: #dc2626;
    font-weight: 600;
  }

  @media (prefers-color-scheme: dark) {
    .prose thead th {
      background: #2d2d2d;
      border-bottom-color: #555;
    }

    .prose tbody td {
      border-bottom-color: #3a3a3a;
    }

    .prose tbody tr:nth-child(even) {
      background: #222;
    }

    .prose tbody tr:hover {
      background: #2a2a2a;
    }

    .prose .result-pass {
      color: #4ade80;
    }

    .prose .result-fail {
      color: #f87171;
    }
  }

  .sources {
    font-size: 0.8rem;
    line-height: 1.5;
    color: var(--text-muted);
  }

  .sources h4 {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
  }

  .sources ul {
    margin-left: 1.2rem;
  }

  .sources li {
    margin-bottom: 0.3rem;
  }

  footer {
    border-top: 1px solid var(--border-muted);
    margin-top: 3rem;
    padding-top: 1.5rem;
    color: var(--text-muted);
    font-size: 0.85rem;
  }

  .draft-banner {
    background: #fef3c7;
    color: #92400e;
    padding: 0.4rem 1rem;
    text-align: center;
    font-size: 0.8rem;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    position: sticky;
    top: 0;
    z-index: 100;
  }

  @media (prefers-color-scheme: dark) {
    .draft-banner {
      background: #422006;
      color: #fef3c7;
    }
  }

  /* ── Commenting system layout ── */

  .page-layout {
    display: flex;
    justify-content: center;
    gap: 0;
    position: relative;
  }

  .container {
    flex: 0 1 42rem;
    min-width: 0;
  }

  .comments-column {
    flex: 0 0 16rem;
    position: relative;
    padding: 2rem 1rem 4rem 0.5rem;
  }

  /* Draft banner buttons */
  .draft-banner {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
  }

  .draft-banner-label {
    font-weight: 600;
    letter-spacing: 0.05em;
  }

  .draft-banner button {
    background: rgba(146, 64, 14, 0.15);
    color: inherit;
    border: 1px solid rgba(146, 64, 14, 0.3);
    padding: 0.15rem 0.6rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-family: inherit;
    cursor: pointer;
    transition: background 0.15s;
  }

  .draft-banner button:hover {
    background: rgba(146, 64, 14, 0.25);
  }

  @media (prefers-color-scheme: dark) {
    .draft-banner button {
      background: rgba(254, 243, 199, 0.1);
      border-color: rgba(254, 243, 199, 0.2);
    }
    .draft-banner button:hover {
      background: rgba(254, 243, 199, 0.2);
    }
  }

  /* Comment highlights in the text */
  mark.comment-highlight {
    background: #fef9c3;
    border-bottom: 2px solid #fde68a;
    border-radius: 2px;
    padding: 0 1px;
    cursor: pointer;
    transition: background 0.15s;
  }

  mark.comment-highlight:hover,
  mark.comment-highlight.active {
    background: #fde68a;
  }

  @media (prefers-color-scheme: dark) {
    mark.comment-highlight {
      background: rgba(254, 249, 195, 0.2);
      border-bottom-color: rgba(253, 230, 138, 0.4);
      color: inherit;
    }
    mark.comment-highlight:hover,
    mark.comment-highlight.active {
      background: rgba(253, 230, 138, 0.35);
    }
  }

  /* Image comment highlights */
  .prose img {
    cursor: pointer;
    transition: outline 0.15s;
  }

  .prose img:hover {
    outline: 2px dashed rgba(245, 158, 11, 0.35);
    outline-offset: 3px;
  }

  .prose img.comment-highlight-img {
    outline: 3px solid #fde68a;
    outline-offset: 3px;
  }

  .prose img.comment-highlight-img:hover,
  .prose img.comment-highlight-img.active {
    outline-color: #f59e0b;
  }

  @media (prefers-color-scheme: dark) {
    .prose img:hover {
      outline-color: rgba(245, 158, 11, 0.25);
    }
    .prose img.comment-highlight-img {
      outline-color: rgba(253, 230, 138, 0.4);
    }
    .prose img.comment-highlight-img:hover,
    .prose img.comment-highlight-img.active {
      outline-color: #f59e0b;
    }
  }

  /* Margin comment cards */
  .comment-card {
    background: #fefce8;
    border: 1px solid #fde68a;
    border-radius: 6px;
    padding: 0.6rem 0.7rem;
    font-size: 0.8rem;
    line-height: 1.45;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
    position: absolute;
    left: 0;
    width: 15rem;
    cursor: pointer;
    transition: border-color 0.15s, box-shadow 0.15s, opacity 0.2s, transform 0.2s;
    opacity: 1;
    transform: translateX(0);
    animation: commentSlideIn 0.2s ease-out;
  }

  @keyframes commentSlideIn {
    from { opacity: 0; transform: translateX(8px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .comment-card:hover {
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }

  .comment-card.active {
    border-color: #f59e0b;
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);
  }

  .comment-card-quote {
    font-style: italic;
    color: #92400e;
    margin-bottom: 0.35rem;
    word-break: break-word;
  }

  .comment-card-text {
    color: #333;
    word-break: break-word;
  }

  .comment-card-delete {
    position: absolute;
    top: 4px;
    right: 6px;
    background: none;
    border: none;
    font-size: 0.85rem;
    color: #b45309;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.15s;
    line-height: 1;
    padding: 2px 4px;
  }

  .comment-card:hover .comment-card-delete {
    opacity: 0.6;
  }

  .comment-card-delete:hover {
    opacity: 1 !important;
  }

  @media (prefers-color-scheme: dark) {
    .comment-card {
      background: #292214;
      border-color: rgba(253, 230, 138, 0.3);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    .comment-card.active {
      border-color: #f59e0b;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }
    .comment-card-quote {
      color: #fcd34d;
    }
    .comment-card-text {
      color: #e0e0e0;
    }
    .comment-card-delete {
      color: #fcd34d;
    }
  }

  /* Floating "Add Comment" button */
  .add-comment-btn {
    position: absolute;
    z-index: 200;
    background: #f59e0b;
    color: #fff;
    border: none;
    padding: 0.3rem 0.75rem;
    border-radius: 999px;
    font-size: 0.78rem;
    font-family: system-ui, -apple-system, sans-serif;
    font-weight: 500;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    white-space: nowrap;
    transition: background 0.15s, transform 0.1s;
    animation: popIn 0.12s ease-out;
  }

  @keyframes popIn {
    from { transform: scale(0.85); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .add-comment-btn:hover {
    background: #d97706;
  }

  /* Floating comment input */
  .comment-input-container {
    position: absolute;
    z-index: 200;
    background: #fefce8;
    border: 1px solid #fde68a;
    border-radius: 8px;
    padding: 0.6rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    width: 18rem;
    animation: popIn 0.12s ease-out;
  }

  .comment-input-container textarea {
    width: 100%;
    border: 1px solid #e5e7eb;
    border-radius: 4px;
    padding: 0.4rem 0.5rem;
    font-size: 0.82rem;
    font-family: inherit;
    line-height: 1.4;
    resize: vertical;
    min-height: 3rem;
    color: #333;
    background: #fff;
  }

  .comment-input-container textarea:focus {
    outline: none;
    border-color: #f59e0b;
    box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.15);
  }

  .comment-input-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.4rem;
    margin-top: 0.4rem;
  }

  .comment-input-actions button {
    padding: 0.25rem 0.6rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-family: inherit;
    cursor: pointer;
    border: none;
  }

  .comment-submit-btn {
    background: #f59e0b;
    color: #fff;
    font-weight: 500;
  }

  .comment-submit-btn:hover {
    background: #d97706;
  }

  .comment-cancel-btn {
    background: #e5e7eb;
    color: #666;
  }

  .comment-cancel-btn:hover {
    background: #d1d5db;
  }

  @media (prefers-color-scheme: dark) {
    .comment-input-container {
      background: #292214;
      border-color: rgba(253, 230, 138, 0.3);
    }
    .comment-input-container textarea {
      background: #1a1a1a;
      color: #e0e0e0;
      border-color: #444;
    }
    .comment-input-container textarea:focus {
      border-color: #f59e0b;
    }
    .comment-cancel-btn {
      background: #444;
      color: #aaa;
    }
  }

  /* Inline comment cards for narrow screens */
  .comment-card-inline {
    background: #fefce8;
    border: 1px solid #fde68a;
    border-radius: 6px;
    padding: 0.5rem 0.65rem;
    font-size: 0.8rem;
    line-height: 1.45;
    margin: 0.5rem 0 1rem 0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
    position: relative;
    cursor: pointer;
    transition: border-color 0.15s;
  }

  .comment-card-inline.active {
    border-color: #f59e0b;
  }

  .comment-card-inline .comment-card-quote {
    font-style: italic;
    color: #92400e;
    margin-bottom: 0.25rem;
  }

  .comment-card-inline .comment-card-text {
    color: #333;
  }

  .comment-card-inline .comment-card-delete {
    position: absolute;
    top: 4px;
    right: 6px;
    background: none;
    border: none;
    font-size: 0.85rem;
    color: #b45309;
    cursor: pointer;
    opacity: 0.4;
    line-height: 1;
    padding: 2px 4px;
  }

  .comment-card-inline .comment-card-delete:hover {
    opacity: 1;
  }

  @media (prefers-color-scheme: dark) {
    .comment-card-inline {
      background: #292214;
      border-color: rgba(253, 230, 138, 0.3);
    }
    .comment-card-inline.active {
      border-color: #f59e0b;
    }
    .comment-card-inline .comment-card-quote { color: #fcd34d; }
    .comment-card-inline .comment-card-text { color: #e0e0e0; }
    .comment-card-inline .comment-card-delete { color: #fcd34d; }
  }

  /* Wide screen: show margin column, hide inline cards */
  @media (min-width: 900px) {
    .comment-card-inline {
      display: none !important;
    }
  }

  /* Narrow screen: hide margin column, show inline cards */
  @media (max-width: 899px) {
    .comments-column {
      display: none !important;
    }
    .page-layout {
      display: block;
    }
  }
</style>
</head>
<body>

<div class="draft-banner">
  <span class="draft-banner-label">DRAFT PREVIEW</span>
  <button id="save-feedback-btn" title="Export comments as JSON">Save Feedback</button>
  <button id="clear-comments-btn" title="Remove all comments">Clear All Comments</button>
</div>

<div class="page-layout">

<div class="container">

<header>
  <h1>The Car Wash Test: Why the Model That Solved a Quantum Breakthrough Can't Wash Your Car</h1>
  <time>2026-02-15</time>
</header>

<div class="prose">

<p>OpenAI's GPT 5.2 Pro has been making headlines. It recently contributed to solving a novel problem in quantum physics, demonstrating chain-of-thought reasoning that left even researchers impressed. This is, by many measures, the most advanced reasoning model ever built. It can dissect abstract mathematical structures, navigate multi-step logical proofs, and synthesize knowledge across scientific domains.</p>

<p>So I asked it a question a five-year-old could answer.</p>

<blockquote>
<p>"I need to wash my car. The car wash is only 100 meters away. Should I walk or take my car there?"</p>
</blockquote>

<p>It thought for two minutes and forty-six seconds. Then it told me to walk.</p>

<p>If you've been on social media lately, you've probably seen this meme circulating. People keep posting screenshots of AI models failing this exact question. The joke is simple: if you need your <em>car</em> washed, the car has to go to the car wash. You can't walk there and leave your dirty car sitting at home. It's a moment of absurdity that lands because the gap between "solved quantum physics" and "doesn't understand car washes" is genuinely funny.</p>

<p>But is this a universal failure, or do some models handle it just fine? I decided to find out. I ran a structured test across 9 model configurations from the three frontier AI companies: OpenAI, Google, and Anthropic.</p>

<h2>The Test</h2>

<p><strong>Methodology:</strong> Same prompt, clean session, no priming, first-shot only. Every model got the identical question with no hints, no follow-ups, and no second chances (unless the model itself asked a clarifying question).</p>

<p>Here are the results.</p>

<table>
<thead>
<tr>
<th>Provider</th>
<th>Model</th>
<th>Result</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenAI</td>
<td>ChatGPT 5.2 Instant</td>
<td><span class="result-fail">Fail</span></td>
<td>Confidently says "Walk." Lists health and engine benefits.</td>
</tr>
<tr>
<td>OpenAI</td>
<td>ChatGPT 5.2 Thinking</td>
<td><span class="result-fail">Fail</span></td>
<td>Same answer. Recovers only when I challenged it: "How will I get my car washed if I am walking?"</td>
</tr>
<tr>
<td>OpenAI</td>
<td>ChatGPT 5.2 Pro</td>
<td><span class="result-fail">Fail</span></td>
<td>Thought for 2m 45s. Lists "vehicle needs to be present" as an exception but still recommends walking.</td>
</tr>
<tr>
<td>Google</td>
<td>Gemini 3 Fast</td>
<td><span class="result-pass">Pass</span></td>
<td>Immediately correct. "Unless you are planning on carrying the car wash equipment back to your driveway..."</td>
</tr>
<tr>
<td>Google</td>
<td>Gemini 3 Thinking</td>
<td><span class="result-pass">Pass</span></td>
<td>Playfully snarky. Calls it "the ultimate efficiency paradox." Asks multiple-choice follow-up about my goals.</td>
</tr>
<tr>
<td>Google</td>
<td>Gemini 3 Pro</td>
<td><span class="result-pass">Pass</span></td>
<td>Clean two-sentence answer. "If you walk, the vehicle will remain dirty at its starting location."</td>
</tr>
<tr>
<td>Anthropic</td>
<td>Claude Haiku 4.5</td>
<td><span class="result-fail">Fail</span></td>
<td>"You should definitely walk." Same failure pattern as smaller models.</td>
</tr>
<tr>
<td>Anthropic</td>
<td>Claude Sonnet 4.5</td>
<td><span class="result-pass">Pass</span></td>
<td>"You should drive your car there!" Acknowledges the irony of driving 100 meters.</td>
</tr>
<tr>
<td>Anthropic</td>
<td>Claude Opus 4.6</td>
<td><span class="result-pass">Pass</span></td>
<td>Instant, confident. "Drive it! The whole point is to get your car washed, so it needs to be there."</td>
</tr>
</tbody>
</table>

<p>A few things jump out immediately:</p>

<p><strong>OpenAI swept the wrong way: 0/3.</strong> Every single OpenAI model failed, including the most powerful reasoning model available today. The model that helped crack a quantum physics problem could not figure out that a car needs to physically be at a car wash.</p>

<p><strong>Google swept the right way: 3/3.</strong> Even Gemini 3 Fast, Google's smallest and cheapest model, nailed it instantly. Not a single hesitation across their entire lineup.</p>

<p><strong>Anthropic split down the middle.</strong> The larger models (Sonnet 4.5 and Opus 4.6) passed easily. The smallest model (Haiku 4.5) fell into the same trap as OpenAI's lineup.</p>

<p><strong>The ChatGPT 5.2 Pro case deserves special attention.</strong> This model spent nearly three minutes reasoning through the problem. In its own chain of thought, it explicitly listed "the wash requires the vehicle to be present" as a consideration. It identified the correct answer, wrote it down in its own notes, and then still concluded: walk. That's not a reasoning failure in the traditional sense. The reasoning was there. The conclusion just didn't follow from it.</p>

<h3>OpenAI: 0 for 3</h3>

<img src="../charts/01_chatgpt_52_instant.png" alt="ChatGPT 5.2 Instant: confidently recommends walking">

<img src="../charts/02_chatgpt_52_thinking_followup.png" alt="ChatGPT 5.2 Thinking: says walk, then corrects when challenged">

<img src="../charts/05_chatgpt_52_pro.png" alt="ChatGPT 5.2 Pro: thinks for 2m 45s, still says walk">

<h3>Google: 3 for 3</h3>

<img src="../charts/04_gemini_3_fast.png" alt="Gemini 3 Fast: immediately gets it right">

<img src="../charts/09_gemini_3_thinking.png" alt="Gemini 3 Thinking: the snarky efficiency paradox response">

<img src="../charts/10_gemini_3_pro.png" alt="Gemini 3 Pro: clean, two-sentence knockout">

<h3>Anthropic: Split Decision</h3>

<img src="../charts/06_claude_haiku_45.png" alt="Claude Haiku 4.5: fails with the same pattern">

<img src="../charts/07_claude_sonnet_45.png" alt="Claude Sonnet 4.5: correct, appreciates the irony">

<img src="../charts/08_claude_opus_46.png" alt="Claude Opus 4.6: instant, no hesitation">

<h2>What Went Wrong?</h2>

<p>Here's the intuition. Most text on the internet about "should I walk or drive 100 meters" says walk. Health blogs, environmental articles, urban planning pieces, general common sense advice. There is an enormous volume of content that pattern-matches "short distance + walk or drive?" to the answer "walk, obviously." AI models are trained on this text. When the question hits that familiar pattern, the statistical prior overwhelmingly favors one answer.</p>

<p>The problem is that this question isn't actually about whether to walk or drive a short distance. It's about getting a specific object to a specific location. The car isn't just your mode of transport here; it's the thing being serviced. Recognizing this requires the model to stop, re-read the premise, and connect two facts: "I need to wash my car" and "the car wash is 100 meters away." The car must physically be at the car wash for the goal to be accomplished.</p>

<p>This is a task that demands overriding the obvious answer with contextual reasoning. And that's surprisingly hard for models, because the obvious answer is backed by millions of training examples all pointing in the same direction.</p>

<p>The ChatGPT 5.2 Pro case is the most revealing failure of the bunch. This model didn't lack reasoning ability. It explicitly noted that the vehicle needs to be present at the car wash. It wrote it down. It considered it. And then it walked right past its own correct analysis and defaulted to the statistical prior anyway. The reasoning was present; the conclusion simply didn't follow. If that doesn't make you pause, it should.</p>

<h2>Pre-training vs. Reasoning: The Deeper Tension</h2>

<p>For those interested in the technical layer underneath, this test exposes a fundamental tension in how modern AI models work: the pull between pre-training distributions and RL-trained reasoning.</p>

<p>Pre-training creates strong statistical priors from internet text. When a model has seen thousands of examples where "short distance" leads to "just walk," that prior becomes deeply embedded in the model's weights. Reinforcement learning from human feedback (RLHF) and chain-of-thought prompting are supposed to provide a reasoning layer that can override those priors when they conflict with logic. But this test shows that the override doesn't always engage.</p>

<p>The prior here is exceptionally strong. Nearly all "short distance, walk or drive" content on the internet says walk. The logical step required to break free of that prior is subtle: you have to re-interpret what the "object" in the scenario actually is. The car isn't just transport. It's the patient. It's the thing that needs to go to the doctor. Missing that re-framing means the model never even realizes there's a conflict between its prior and the correct answer.</p>

<p>Why might Gemini have swept 3/3? We can only speculate. It could be a different training data mix, a different weighting in RLHF tuning that emphasizes practical and physical reasoning, or architectural differences in how reasoning interacts with priors. We can't know for sure without access to the training details. But the 3/3 vs 0/3 split between Google and OpenAI is too clean to ignore.</p>

<p>The ChatGPT 5.2 Thinking model's recovery when challenged is worth noting too. When I followed up with "How will I get my car washed if I am walking?", the model immediately course-corrected. It didn't struggle. It didn't hedge. It just got it right. This tells us the reasoning capability absolutely exists within the model. It just doesn't activate on the first pass without that additional context nudge. The model needs to be told that its pattern-matched answer is wrong before it engages the deeper reasoning that was available all along.</p>

<h2>The Car Wash Test Isn't Alone</h2>

<p>This kind of failure has a family history. The car wash test joins a lineage of deceptively simple questions that expose model blind spots:</p>

<ul>
<li><strong>"How many R's in strawberry?"</strong> Models consistently said 2 (there are 3). Tokenization means the model never "sees" individual letters; it processes tokens, not characters, and can't reliably count within them.</li>
<li><strong>"Is 9.11 greater than 9.9?"</strong> Models said yes, likely treating the decimal portions as integers (11 > 9) rather than understanding decimal place value.</li>
</ul>

<p>The common thread across all of these: they aren't hard problems. A child can answer each one correctly. They're problems where the obvious pattern-match answer is wrong, and the model has to resist its own statistical instincts to arrive at the truth.</p>

<p>The car wash test adds a new dimension to this family. It's not about tokenization quirks or number formatting. It's about understanding the physical relationship between an action (washing) and an object (the car). The model needs to reason about what needs to be <em>where</em> for the goal to be accomplished. That's spatial, physical, and goal-oriented reasoning all wrapped into one sentence. And the fact that a simple, silly question can expose that gap is exactly what makes it so useful.</p>

<h2>Testing the Edges</h2>

<p>I want to be clear about something: these tests aren't about dunking on AI. I'm not here to point and laugh. The same GPT 5.2 Pro that couldn't figure out the car wash question contributed to a genuine quantum physics breakthrough. These models are extraordinarily powerful tools that are already changing how research, engineering, and creative work get done. I believe in that potential deeply.</p>

<p>But they have blind spots. And finding those blind spots matters. Every viral failure like the car wash test is data. It's a signal. It tells researchers exactly what kind of reasoning still needs work: the ability to override strong statistical priors when physical context demands it, the ability to re-frame what the "object" in a scenario actually is, the ability to follow your own chain of thought to its logical conclusion instead of snapping back to the default.</p>

<p>The best way to trust AI more is to understand precisely where it fails.</p>

</div>

<footer>
</footer>

</div>

<div class="comments-column" id="comments-column"></div>

</div>

<script>
(function() {
  'use strict';

  // ── State ──
  var STORAGE_KEY = 'draft-comments-' + slugify(document.title);
  var comments = []; // Array of { id, selectedText, comment, section, paragraphContext, charOffset }
  var commentCounter = 0;
  var activeCommentId = null;

  // ── DOM references ──
  var prose = document.querySelector('.prose');
  var commentsColumn = document.getElementById('comments-column');
  var saveFeedbackBtn = document.getElementById('save-feedback-btn');
  var clearCommentsBtn = document.getElementById('clear-comments-btn');

  // Floating UI elements (created on demand)
  var addCommentBtn = null;
  var commentInputContainer = null;
  var pendingSelection = null; // text: { type, text, range, rect, paragraph, charOffset, section } or image: { type, text, imgSrc, imgAlt, imgEl, rect, section }

  // ── Utility functions ──

  function slugify(str) {
    return str.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
  }

  function generateId() {
    commentCounter++;
    return 'comment-' + Date.now() + '-' + commentCounter;
  }

  function truncate(str, len) {
    if (str.length <= len) return str;
    return str.slice(0, len - 1) + '\u2026';
  }

  function removeAllChildren(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }

  function getNearestHeading(node) {
    var el = node.nodeType === 3 ? node.parentElement : node;
    while (el && el !== prose) {
      var prev = el.previousElementSibling;
      while (prev) {
        if (prev.tagName === 'H2' || prev.tagName === 'H3') {
          return prev.textContent.trim();
        }
        prev = prev.previousElementSibling;
      }
      el = el.parentElement;
    }
    return '';
  }

  function getContainingParagraph(node) {
    var el = node.nodeType === 3 ? node.parentElement : node;
    while (el && el !== prose) {
      if (el.tagName === 'P' || el.tagName === 'LI') return el;
      el = el.parentElement;
    }
    return null;
  }

  function getCharOffsetInParagraph(paragraph, range) {
    var walker = document.createTreeWalker(paragraph, NodeFilter.SHOW_TEXT, null, false);
    var offset = 0;
    var node;
    while ((node = walker.nextNode())) {
      if (node === range.startContainer) {
        return offset + range.startOffset;
      }
      offset += node.textContent.length;
    }
    return offset;
  }

  // ── Highlight wrapping ──

  function wrapRangeWithMark(range, commentId) {
    var mark = document.createElement('mark');
    mark.className = 'comment-highlight';
    mark.dataset.commentId = commentId;
    try {
      range.surroundContents(mark);
    } catch (e) {
      var fragment = range.extractContents();
      mark.appendChild(fragment);
      range.insertNode(mark);
    }
    mark.addEventListener('click', function() {
      setActiveComment(commentId);
      scrollToCard(commentId);
    });
    return mark;
  }

  function findAndHighlightText(commentData) {
    var paragraphs = prose.querySelectorAll('p, li');
    var targetParagraph = null;
    for (var i = 0; i < paragraphs.length; i++) {
      var pText = paragraphs[i].textContent.slice(0, 100);
      if (pText === commentData.paragraphContext) {
        targetParagraph = paragraphs[i];
        break;
      }
    }
    if (!targetParagraph) return false;

    var fullText = targetParagraph.textContent;
    var searchText = commentData.selectedText;
    var expectedOffset = commentData.charOffset;

    var idx = fullText.indexOf(searchText, Math.max(0, expectedOffset - 5));
    if (idx === -1) {
      idx = fullText.indexOf(searchText);
    }
    if (idx === -1) return false;

    var walker = document.createTreeWalker(targetParagraph, NodeFilter.SHOW_TEXT, null, false);
    var currentOffset = 0;
    var startNode = null, startOff = 0, endNode = null, endOff = 0;
    var node;
    while ((node = walker.nextNode())) {
      var nodeLen = node.textContent.length;
      if (!startNode && currentOffset + nodeLen > idx) {
        startNode = node;
        startOff = idx - currentOffset;
      }
      if (startNode && currentOffset + nodeLen >= idx + searchText.length) {
        endNode = node;
        endOff = idx + searchText.length - currentOffset;
        break;
      }
      currentOffset += nodeLen;
    }

    if (!startNode || !endNode) return false;

    var range = document.createRange();
    range.setStart(startNode, startOff);
    range.setEnd(endNode, endOff);

    wrapRangeWithMark(range, commentData.id);
    return true;
  }

  function removeHighlight(commentId) {
    var marks = prose.querySelectorAll('mark[data-comment-id="' + commentId + '"]');
    marks.forEach(function(mark) {
      var parent = mark.parentNode;
      while (mark.firstChild) {
        parent.insertBefore(mark.firstChild, mark);
      }
      parent.removeChild(mark);
      parent.normalize();
    });
  }

  // ── Image comment helpers ──

  function getImageForComment(commentData) {
    var imgs = prose.querySelectorAll('img');
    for (var i = 0; i < imgs.length; i++) {
      if (imgs[i].getAttribute('src') === commentData.imgSrc) return imgs[i];
    }
    return null;
  }

  function addImageHighlight(img, commentId) {
    img.classList.add('comment-highlight-img');
    var ids = (img.dataset.commentIds || '').split(' ').filter(Boolean);
    if (ids.indexOf(commentId) === -1) ids.push(commentId);
    img.dataset.commentIds = ids.join(' ');
    img.addEventListener('click', onImageClick);
  }

  function removeImageHighlight(img, commentId) {
    var ids = (img.dataset.commentIds || '').split(' ').filter(Boolean);
    ids = ids.filter(function(id) { return id !== commentId; });
    if (ids.length === 0) {
      img.classList.remove('comment-highlight-img');
      img.classList.remove('active');
      delete img.dataset.commentIds;
    } else {
      img.dataset.commentIds = ids.join(' ');
    }
  }

  function getAnchorForComment(commentData) {
    if (commentData.type === 'image') {
      return getImageForComment(commentData);
    }
    return prose.querySelector('mark[data-comment-id="' + commentData.id + '"]');
  }

  // ── Comment cards ──

  function renderAllCards() {
    removeAllChildren(commentsColumn);

    var inlineCards = prose.querySelectorAll('.comment-card-inline');
    for (var i = 0; i < inlineCards.length; i++) {
      inlineCards[i].remove();
    }

    for (var j = 0; j < comments.length; j++) {
      createMarginCard(comments[j]);
      createInlineCard(comments[j]);
    }

    positionMarginCards();
  }

  function createMarginCard(commentData) {
    var card = document.createElement('div');
    card.className = 'comment-card';
    if (commentData.id === activeCommentId) card.classList.add('active');
    card.dataset.commentId = commentData.id;

    var quote = document.createElement('div');
    quote.className = 'comment-card-quote';
    if (commentData.type === 'image') {
      quote.textContent = 'Chart: ' + truncate(commentData.imgAlt || commentData.imgSrc, 50);
    } else {
      quote.textContent = '\u201c' + truncate(commentData.selectedText, 50) + '\u201d';
    }

    var text = document.createElement('div');
    text.className = 'comment-card-text';
    text.textContent = commentData.comment;

    var del = document.createElement('button');
    del.className = 'comment-card-delete';
    del.textContent = '\u00d7';
    del.title = 'Delete comment';
    del.addEventListener('click', function(e) {
      e.stopPropagation();
      deleteComment(commentData.id);
    });

    card.appendChild(quote);
    card.appendChild(text);
    card.appendChild(del);

    card.addEventListener('click', function() {
      setActiveComment(commentData.id);
      scrollToHighlight(commentData.id);
    });

    commentsColumn.appendChild(card);
  }

  function createInlineCard(commentData) {
    var anchor = getAnchorForComment(commentData);
    if (!anchor) return;

    var card = document.createElement('div');
    card.className = 'comment-card-inline';
    if (commentData.id === activeCommentId) card.classList.add('active');
    card.dataset.commentId = commentData.id;

    var quote = document.createElement('div');
    quote.className = 'comment-card-quote';
    if (commentData.type === 'image') {
      quote.textContent = 'Chart: ' + truncate(commentData.imgAlt || commentData.imgSrc, 50);
    } else {
      quote.textContent = '\u201c' + truncate(commentData.selectedText, 50) + '\u201d';
    }

    var text = document.createElement('div');
    text.className = 'comment-card-text';
    text.textContent = commentData.comment;

    var del = document.createElement('button');
    del.className = 'comment-card-delete';
    del.textContent = '\u00d7';
    del.title = 'Delete comment';
    del.addEventListener('click', function(e) {
      e.stopPropagation();
      deleteComment(commentData.id);
    });

    card.appendChild(quote);
    card.appendChild(text);
    card.appendChild(del);

    card.addEventListener('click', function() {
      setActiveComment(commentData.id);
      scrollToHighlight(commentData.id);
    });

    var parent = commentData.type === 'image' ? anchor : anchor.closest('p, li, h2, h3, img');
    if (parent && parent.parentNode) {
      parent.parentNode.insertBefore(card, parent.nextSibling);
    }
  }

  function positionMarginCards() {
    var cards = commentsColumn.querySelectorAll('.comment-card');
    var scrollY = window.scrollY || document.documentElement.scrollTop;
    var columnTop = commentsColumn.getBoundingClientRect().top + scrollY;
    var lastBottom = 0;

    for (var i = 0; i < cards.length; i++) {
      var card = cards[i];
      var commentId = card.dataset.commentId;
      var commentData = comments.find(function(c) { return c.id === commentId; });
      var anchor = commentData ? getAnchorForComment(commentData) : null;
      if (!anchor) {
        // Fallback: try mark element directly
        anchor = prose.querySelector('mark[data-comment-id="' + commentId + '"]');
      }
      if (!anchor) continue;

      var anchorRect = anchor.getBoundingClientRect();
      var desiredTop = anchorRect.top + scrollY - columnTop;

      if (desiredTop < lastBottom + 8) {
        desiredTop = lastBottom + 8;
      }

      card.style.top = desiredTop + 'px';
      lastBottom = desiredTop + card.offsetHeight;
    }
  }

  // ── Active comment highlighting ──

  function setActiveComment(commentId) {
    activeCommentId = commentId;

    var highlights = prose.querySelectorAll('mark.comment-highlight');
    for (var i = 0; i < highlights.length; i++) {
      highlights[i].classList.toggle('active', highlights[i].dataset.commentId === commentId);
    }

    // Toggle active state on commented images
    var commentedImgs = prose.querySelectorAll('img.comment-highlight-img');
    for (var m = 0; m < commentedImgs.length; m++) {
      var imgIds = (commentedImgs[m].dataset.commentIds || '').split(' ');
      commentedImgs[m].classList.toggle('active', imgIds.indexOf(commentId) !== -1);
    }

    var marginCards = commentsColumn.querySelectorAll('.comment-card');
    for (var j = 0; j < marginCards.length; j++) {
      marginCards[j].classList.toggle('active', marginCards[j].dataset.commentId === commentId);
    }

    var inlineCards = prose.querySelectorAll('.comment-card-inline');
    for (var k = 0; k < inlineCards.length; k++) {
      inlineCards[k].classList.toggle('active', inlineCards[k].dataset.commentId === commentId);
    }
  }

  function scrollToCard(commentId) {
    var isWide = window.innerWidth >= 900;
    var card;
    if (isWide) {
      card = commentsColumn.querySelector('.comment-card[data-comment-id="' + commentId + '"]');
    } else {
      card = prose.querySelector('.comment-card-inline[data-comment-id="' + commentId + '"]');
    }
    if (card) {
      card.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function scrollToHighlight(commentId) {
    var commentData = comments.find(function(c) { return c.id === commentId; });
    var anchor = commentData ? getAnchorForComment(commentData) : null;
    if (!anchor) {
      anchor = prose.querySelector('mark[data-comment-id="' + commentId + '"]');
    }
    if (anchor) {
      anchor.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  // ── Floating "Add Comment" button ──

  function showAddCommentButton(x, y) {
    removeAddCommentButton();
    addCommentBtn = document.createElement('button');
    addCommentBtn.className = 'add-comment-btn';
    addCommentBtn.textContent = 'Comment';
    addCommentBtn.style.left = x + 'px';
    addCommentBtn.style.top = y + 'px';
    document.body.appendChild(addCommentBtn);

    addCommentBtn.addEventListener('mousedown', function(e) {
      e.preventDefault();
      e.stopPropagation();
    });
    addCommentBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      showCommentInput();
    });
  }

  function removeAddCommentButton() {
    if (addCommentBtn && addCommentBtn.parentNode) {
      addCommentBtn.parentNode.removeChild(addCommentBtn);
    }
    addCommentBtn = null;
  }

  // ── Comment input ──

  function showCommentInput() {
    removeAddCommentButton();
    removeCommentInput();
    if (!pendingSelection) return;

    commentInputContainer = document.createElement('div');
    commentInputContainer.className = 'comment-input-container';

    var textarea = document.createElement('textarea');
    textarea.placeholder = 'Add your comment\u2026';
    textarea.rows = 2;

    var actions = document.createElement('div');
    actions.className = 'comment-input-actions';

    var cancelBtn = document.createElement('button');
    cancelBtn.className = 'comment-cancel-btn';
    cancelBtn.textContent = 'Cancel';

    var submitBtn = document.createElement('button');
    submitBtn.className = 'comment-submit-btn';
    submitBtn.textContent = 'Add';

    actions.appendChild(cancelBtn);
    actions.appendChild(submitBtn);

    commentInputContainer.appendChild(textarea);
    commentInputContainer.appendChild(actions);

    var scrollY = window.scrollY || document.documentElement.scrollTop;
    var scrollX = window.scrollX || document.documentElement.scrollLeft;
    var rect = pendingSelection.rect;
    var left = rect.right + scrollX + 8;
    var top = rect.top + scrollY;

    if (left + 288 > window.innerWidth + scrollX) {
      left = rect.left + scrollX - 296;
    }
    if (left < scrollX + 8) {
      left = scrollX + 8;
    }

    commentInputContainer.style.left = left + 'px';
    commentInputContainer.style.top = top + 'px';
    document.body.appendChild(commentInputContainer);
    textarea.focus();

    submitBtn.addEventListener('click', function() {
      submitComment(textarea.value.trim());
    });

    cancelBtn.addEventListener('click', function() {
      removeCommentInput();
      pendingSelection = null;
    });

    textarea.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        submitComment(textarea.value.trim());
      }
      if (e.key === 'Escape') {
        removeCommentInput();
        pendingSelection = null;
      }
    });
  }

  function removeCommentInput() {
    if (commentInputContainer && commentInputContainer.parentNode) {
      commentInputContainer.parentNode.removeChild(commentInputContainer);
    }
    commentInputContainer = null;
  }

  function submitComment(text) {
    if (!text || !pendingSelection) {
      removeCommentInput();
      pendingSelection = null;
      return;
    }

    var id = generateId();
    var commentData;

    if (pendingSelection.type === 'image') {
      commentData = {
        id: id,
        type: 'image',
        selectedText: pendingSelection.imgAlt || pendingSelection.imgSrc,
        comment: text,
        section: pendingSelection.section,
        imgSrc: pendingSelection.imgSrc,
        imgAlt: pendingSelection.imgAlt
      };
      addImageHighlight(pendingSelection.imgEl, id);
    } else {
      commentData = {
        id: id,
        type: 'text',
        selectedText: pendingSelection.text,
        comment: text,
        section: pendingSelection.section,
        paragraphContext: pendingSelection.paragraphContext,
        charOffset: pendingSelection.charOffset
      };
      try {
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(pendingSelection.range);
        wrapRangeWithMark(pendingSelection.range, id);
      } catch(e) {
        findAndHighlightText(commentData);
      }
    }

    comments.push(commentData);
    saveToLocalStorage();
    removeCommentInput();
    pendingSelection = null;

    renderAllCards();
    setActiveComment(id);

    requestAnimationFrame(function() { positionMarginCards(); });
  }

  // ── Delete comment ──

  function deleteComment(commentId) {
    var commentData = comments.find(function(c) { return c.id === commentId; });
    if (commentData && commentData.type === 'image') {
      var img = getImageForComment(commentData);
      if (img) removeImageHighlight(img, commentId);
    } else {
      removeHighlight(commentId);
    }
    comments = comments.filter(function(c) { return c.id !== commentId; });
    if (activeCommentId === commentId) activeCommentId = null;
    saveToLocalStorage();
    renderAllCards();
  }

  // ── Persistence ──

  function saveToLocalStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(comments));
    } catch(e) { /* silently fail */ }
  }

  function loadFromLocalStorage() {
    try {
      var stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        comments = JSON.parse(stored);
        for (var i = 0; i < comments.length; i++) {
          var parts = comments[i].id.split('-');
          var num = parseInt(parts[parts.length - 1], 10);
          if (num > commentCounter) commentCounter = num;
        }
      }
    } catch(e) {
      comments = [];
    }
  }

  function restoreComments() {
    loadFromLocalStorage();
    for (var i = 0; i < comments.length; i++) {
      if (comments[i].type === 'image') {
        var img = getImageForComment(comments[i]);
        if (img) addImageHighlight(img, comments[i].id);
      } else {
        findAndHighlightText(comments[i]);
      }
    }
    renderAllCards();
  }

  // ── Save feedback to file ──

  function saveFeedback() {
    var exportData = {
      draft: document.title,
      timestamp: new Date().toISOString(),
      comments: comments.map(function(c) {
        var out = {
          id: c.id,
          type: c.type || 'text',
          selectedText: c.selectedText,
          comment: c.comment,
          section: c.section
        };
        if (c.type === 'image') {
          out.imgSrc = c.imgSrc;
          out.imgAlt = c.imgAlt;
        } else {
          out.paragraphContext = c.paragraphContext;
        }
        return out;
      })
    };

    var json = JSON.stringify(exportData, null, 2);

    if (window.showSaveFilePicker) {
      window.showSaveFilePicker({
        suggestedName: 'feedback.json',
        types: [{
          description: 'JSON files',
          accept: { 'application/json': ['.json'] }
        }]
      }).then(function(handle) {
        return handle.createWritable().then(function(writable) {
          return writable.write(json).then(function() {
            return writable.close();
          });
        });
      }).catch(function(e) {
        if (e.name === 'AbortError') return;
        downloadFallback(json);
      });
    } else {
      downloadFallback(json);
    }
  }

  function downloadFallback(json) {
    var blob = new Blob([json], { type: 'application/json' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'feedback.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ── Clear all comments ──

  function clearAllComments() {
    if (comments.length === 0) return;
    if (!confirm('Remove all comments? This cannot be undone.')) return;

    for (var i = 0; i < comments.length; i++) {
      if (comments[i].type === 'image') {
        var img = getImageForComment(comments[i]);
        if (img) removeImageHighlight(img, comments[i].id);
      } else {
        removeHighlight(comments[i].id);
      }
    }
    comments = [];
    activeCommentId = null;
    saveToLocalStorage();
    renderAllCards();
  }

  // ── Selection handling ──

  function handleMouseUp(e) {
    if (e.target.closest('.add-comment-btn, .comment-input-container, .comment-card, .comment-card-inline, .draft-banner')) {
      return;
    }

    // Skip text selection handling when clicking on images (handled by onImageClick)
    if (e.target.tagName === 'IMG' && e.target.closest('.prose')) {
      return;
    }

    if (commentInputContainer && !e.target.closest('.comment-input-container')) {
      removeCommentInput();
      pendingSelection = null;
    }

    var sel = window.getSelection();
    if (!sel || sel.isCollapsed || !sel.rangeCount) {
      removeAddCommentButton();
      return;
    }

    var range = sel.getRangeAt(0);
    var text = sel.toString().trim();
    if (!text) {
      removeAddCommentButton();
      return;
    }

    var container = range.commonAncestorContainer;
    var inProse = (container.nodeType === 3 ? container.parentElement : container).closest('.prose');
    if (!inProse) {
      removeAddCommentButton();
      return;
    }

    var startInMark = range.startContainer.nodeType === 3
      ? range.startContainer.parentElement.closest('mark.comment-highlight')
      : range.startContainer.closest ? range.startContainer.closest('mark.comment-highlight') : null;
    if (startInMark) {
      removeAddCommentButton();
      return;
    }

    var paragraph = getContainingParagraph(range.startContainer);
    var paragraphContext = paragraph ? paragraph.textContent.slice(0, 100) : '';
    var charOffset = paragraph ? getCharOffsetInParagraph(paragraph, range) : 0;
    var section = getNearestHeading(range.startContainer);

    pendingSelection = {
      text: text,
      range: range.cloneRange(),
      rect: range.getBoundingClientRect(),
      paragraph: paragraph,
      paragraphContext: paragraphContext,
      charOffset: charOffset,
      section: section
    };

    var scrollY = window.scrollY || document.documentElement.scrollTop;
    var scrollX = window.scrollX || document.documentElement.scrollLeft;
    var rect = range.getBoundingClientRect();
    var btnX = rect.right + scrollX + 4;
    var btnY = rect.top + scrollY - 32;

    if (btnX + 80 > window.innerWidth + scrollX) {
      btnX = rect.left + scrollX;
    }
    if (btnY < scrollY) {
      btnY = rect.bottom + scrollY + 4;
    }

    showAddCommentButton(btnX, btnY);
  }

  function onImageClick(e) {
    var img = e.target;
    if (!img || img.tagName !== 'IMG' || !img.closest('.prose')) return;

    // If there's an open comment input, close it
    removeAddCommentButton();
    removeCommentInput();

    var section = getNearestHeading(img);
    var rect = img.getBoundingClientRect();

    pendingSelection = {
      type: 'image',
      text: img.alt || img.src,
      imgSrc: img.getAttribute('src'),
      imgAlt: img.getAttribute('alt') || '',
      imgEl: img,
      rect: rect,
      section: section
    };

    var scrollY = window.scrollY || document.documentElement.scrollTop;
    var scrollX = window.scrollX || document.documentElement.scrollLeft;
    var btnX = rect.right + scrollX - 80;
    var btnY = rect.top + scrollY + 8;

    showAddCommentButton(btnX, btnY);
    e.stopPropagation();
  }

  function handleClick(e) {
    if (e.target.closest('.comment-card, .comment-card-inline, mark.comment-highlight, .add-comment-btn, .comment-input-container') || (e.target.tagName === 'IMG' && e.target.closest('.prose'))) {
      return;
    }
    if (activeCommentId) {
      setActiveComment(null);
    }
  }

  function handleResizeOrScroll() {
    positionMarginCards();
  }

  // ── Wire up events ──

  document.addEventListener('mouseup', handleMouseUp);
  document.addEventListener('click', handleClick);
  window.addEventListener('resize', handleResizeOrScroll);
  window.addEventListener('scroll', handleResizeOrScroll);

  saveFeedbackBtn.addEventListener('click', saveFeedback);
  clearCommentsBtn.addEventListener('click', clearAllComments);

  // ── Initialize ──

  // Attach click handlers to all images in prose
  var proseImages = prose.querySelectorAll('img');
  for (var ii = 0; ii < proseImages.length; ii++) {
    proseImages[ii].addEventListener('click', onImageClick);
  }

  restoreComments();

  window.addEventListener('load', function() {
    positionMarginCards();
  });
})();
</script>

</body>
</html>